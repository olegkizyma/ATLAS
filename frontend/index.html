<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlas Minimal Interface</title>
    <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* 3D Viewer Background Layer */
        .background-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        model-viewer {
            width: 100%;
            height: 100%;
            background-color: #000000;
            opacity: 0.3;
        }

        /* Interface Overlay Layer */
        .interface-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* Left Panel - MCP Logs */
        .logs-panel {
            position: absolute;
            left: 0;
            top: 0;
            width: 30%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px; /* —Ä—ñ–≤–Ω–æ–º—ñ—Ä–Ω–æ; —Ç–µ–∫—Å—Ç –≤—ñ–¥—Å—Ç—É–ø–∏–º–æ –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
            pointer-events: auto;
            border-right: none; /* –±–µ–∑ –ª—ñ–Ω—ñ—ó */
        }

        .logs-container {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 12px; /* —Ç—Ä–æ—Ö–∏ –º–µ–Ω—à–µ, –±–æ —Å–∫—Ä–æ–ª —Å—Ö–æ–≤–∞–Ω–∏–π */
            /* scrollbar-width: none;  (Removed for broader compatibility) */
            -ms-overflow-style: none; /* IE / —Å—Ç–∞—Ä–∏–π Edge */
        }

        .logs-container::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        .log-line {
            color: #4a9c5a;
            margin: 0;
            padding: 2px 0 1px 0; /* —Ç—Ä–æ—Ö–∏ –±—ñ–ª—å—à–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—ñ–¥—Å—Ç—É–ø—É –¥–ª—è –±—ñ–ª—å—à–æ–≥–æ —à—Ä–∏—Ñ—Ç—É */
            word-wrap: break-word;
            font-size: 11px; /* –±—É–ª–æ 10px */
            line-height: 1.28; /* –ø—ñ–¥–ª–∞—à—Ç–æ–≤–∞–Ω–æ –¥–ª—è —á–∏—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—ñ */
            font-family: 'Courier New', monospace;
            font-weight: normal; /* –Ω–µ –∂–∏—Ä–Ω–∏–π —à—Ä–∏—Ñ—Ç */
            white-space: pre-wrap;
            letter-spacing: 0.3px; /* –ª–µ–≥–∫–µ —Ä–æ–∑—Ä—ñ–¥–∂–µ–Ω–Ω—è –¥–ª—è —Ö–∞–∫–µ—Ä—Å—å–∫–æ–≥–æ –≤–∏–≥–ª—è–¥—É */
        }

        .log-line.error {
            color: #d16969;
        }

        .log-line.warning {
            color: #d19a66;
        }

        .log-line.info {
            color: #5c9e5c;
        }

        .log-line.debug {
            color: #4a7a5a;
            opacity: 0.7;
        }

        /* Right Panel - Chat */
        .chat-panel {
            position: absolute;
            right: 0;
            top: 0;
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            pointer-events: auto;
            border-left: 1px solid rgba(0, 255, 65, 0.1);
            display: flex;
            flex-direction: column;
        }

        /* Status Panel - System Status */
        .status-panel {
            position: absolute;
            left: 30%;
            top: 0;
            width: 20%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            pointer-events: auto;
            font-size: 10px;
            border-left: 1px solid rgba(0, 255, 65, 0.1);
        }

        .status-container {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 8px;
        }

        .status-section {
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
            padding-bottom: 6px;
        }

        .status-title {
            color: #00ff41;
            font-weight: bold;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .status-item {
            color: #00ff41;
            margin: 1px 0;
            font-size: 9px;
            opacity: 0.8;
        }

        .status-item.online {
            color: #00ff41;
        }

        .status-item.warning {
            color: #ffff41;
        }

        .status-item.error {
            color: #ff4141;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
            margin-bottom: 8px;
        }

        .message {
            margin-bottom: 6px;
            padding: 4px 6px;
            border: 1px solid rgba(0, 255, 65, 0.1);
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.2);
        }

        .message.user {
            border-color: rgba(0, 255, 65, 0.3);
            text-align: right;
        }

        .message.assistant {
            border-color: rgba(0, 255, 65, 0.2);
        }

        .message-text {
            color: #00ff41;
            font-size: 11px;
            line-height: 1.3;
        }

        .message-time {
            color: #006622;
            font-size: 9px;
            margin-top: 2px;
        }

        /* Chat Input Area */
        .chat-input-area {
            display: flex;
            gap: 6px;
            align-items: flex-end;
            position: relative;
        }



        .chat-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 65, 0.2);
            color: #00ff41;
            padding: 6px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            resize: none;
            min-height: 20px;
            max-height: 60px;
        }

        .chat-input:focus {
            outline: none;
            border-color: rgba(0, 255, 65, 0.4);
        }

        .voice-button {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 65, 0.2);
            color: #00ff41;
            padding: 6px 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            transition: all 0.2s;
        }

        .voice-button:hover {
            border-color: rgba(0, 255, 65, 0.4);
            background: rgba(0, 255, 65, 0.1);
        }

        .voice-button.listening {
            background: rgba(0, 255, 65, 0.2);
            border-color: rgba(0, 255, 65, 0.6);
        }

        .voice-button.continuous {
            background: rgba(255, 255, 65, 0.2);
            border-color: rgba(255, 255, 65, 0.6);
            color: #ffff41;
        }

        /* Session Controls */
        .session-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .current-session {
            font-size: 12px;
            color: #495057;
            background: #ffffff;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            margin-left: auto;
            white-space: nowrap;
        }        .session-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 65, 0.2);
            color: #00ff41;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
            min-width: 24px;
        }

        .session-btn:hover {
            border-color: rgba(0, 255, 65, 0.4);
            background: rgba(0, 255, 65, 0.1);
        }

        .session-btn.active {
            background: rgba(0, 255, 65, 0.2);
            border-color: rgba(0, 255, 65, 0.6);
        }

        .current-session {
            font-size: 9px;
            color: rgba(0, 255, 65, 0.6);
            margin-left: 4px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 65, 0.3);
            border-radius: 2px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 65, 0.5);
        }
    </style>
</head>
<body>
    <!-- Background 3D Layer -->
    <div class="background-layer">
        <model-viewer 
            src="DamagedHelmet.glb" 
            alt="Atlas 3D Interface"
            auto-rotate 
            camera-controls 
            environment-image="neutral"
            exposure="0.1"
            shadow-intensity="0.02"
            tone-mapping="neutral">
        </model-viewer>
    </div>

    <!-- Interface Overlay -->
    <div class="interface-layer">
        <!-- Left Panel - MCP Logs -->
        <div class="logs-panel">
            <div class="logs-container" id="logsContainer">
                <div class="log-line debug">[05:21:07] [ATLAS] System initializing...</div>
                <div class="log-line debug">[05:21:09] [TTS] Service ready</div>
                <div class="log-line debug">[05:21:10] [AUTO] Automation ready</div>
                <div class="log-line debug">[05:21:11] [NET] Ports listening</div>
            </div>
        </div>

        <!-- Status Panel - System Status -->
        <div class="status-panel">
            <div class="status-container" id="statusContainer">
                <div class="status-section">
                    <div class="status-title">PROCESSES</div>
                    <div id="processStatus">
                        <div class="status-item">Atlas: 0</div>
                        <div class="status-item">Goose: 0</div>
                        <div class="status-item">MCP: 0</div>
                    </div>
                </div>
                
                <div class="status-section">
                    <div class="status-title">SERVICES</div>
                    <div id="serviceStatus">
                        <div class="status-item">Core: offline</div>
                        <div class="status-item">MCP: offline</div>
                    </div>
                </div>
                
                <div class="status-section">
                    <div class="status-title">NETWORK</div>
                    <div id="networkStatus">
                        <div class="status-item">Connections: 0</div>
                    </div>
                </div>
                
                <div class="status-section">
                    <div class="status-title">RESOURCES</div>
                    <div id="resourceStatus">
                        <div class="status-item">CPU: --</div>
                        <div class="status-item">Disk: --</div>
                    </div>
                </div>
                
                <div class="status-section">
                    <div class="status-title">ATLAS INTELLIGENCE</div>
                    <div id="atlasIntelligenceStatus">
                        <div class="status-item">Auto-corrections: --</div>
                        <div class="status-item">Grisha verifications: --</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Chat -->
        <div class="chat-panel">
            <div class="chat-messages" id="chatMessages">
                <div class="message assistant">
                    <div class="message-text">Atlas Minimal Interface –∞–∫—Ç–∏–≤–Ω–∏–π</div>
                    <div class="message-time">00:00:01</div>
                </div>
            </div>
            
            <div class="chat-input-area">

                <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Å–µ—Å—ñ—è–º–∏ -->
                <div class="session-controls">
                    <button id="newSessionBtn" class="session-btn new-session" title="–ù–æ–≤–µ –∑–∞–≤–¥–∞–Ω–Ω—è">üÜï</button>
                    <button id="continueSessionBtn" class="session-btn continue-session" title="–ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ –ø–æ—Ç–æ—á–Ω–µ">‚ñ∂Ô∏è</button>
                    <span id="currentSession" class="current-session">–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ</span>
                </div>
                
                <textarea 
                    id="chatInput" 
                    class="chat-input" 
                    placeholder="–í–≤–µ–¥—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è..."
                    rows="1"></textarea>
                <button id="voiceButton" class="voice-button">üé§</button>
            </div>
        </div>
    </div>

    <script>
    class AtlasMinimalInterface {
            constructor() {
                this.voiceMode = 'off'; // 'off', 'single', 'continuous'
                this.recognition = null;
                this.isListening = false;
                this.clickCount = 0;
                this.clickTimer = null;
                this.singleModeSendTimer = null; // —Ç–∞–π–º–µ—Ä –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è 3s —É single —Ä–µ–∂–∏–º—ñ
                this.lastFinalTimestamp = 0;
                this.TTSBlockTimer = null; // –ø–∞—É–∑–∞ –¥–ª—è continuous –ø—ñ–¥ —á–∞—Å "–º–æ–≤–ª–µ–Ω–Ω—è"
                this.TTS_ACTIVE = false;
                
                // –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è —Å–µ—Å—ñ—è–º–∏
                this.sessionMode = 'auto'; // 'auto', 'new', 'continue'
                this.currentSessionName = null;
                this.TTSBlockTimer = null; // –ø–∞—É–∑–∞ –¥–ª—è continuous –ø—ñ–¥ —á–∞—Å "–º–æ–≤–ª–µ–Ω–Ω—è"
                this.TTS_ACTIVE = false;
                this.SINGLE_INACTIVITY_MS = 3000; // 3s –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ —Ñ—ñ–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
                this.MIN_FINAL_CHARS_TO_SEND = 2;
                
                this.initializeElements();
                this.initializeVoiceRecognition();
                this.startMCPLogging();
                this.startStatusMonitoring();
                this.bindEvents();
            }

            initializeElements() {
                this.chatInput = document.getElementById('chatInput');
                this.chatMessages = document.getElementById('chatMessages');
                this.voiceButton = document.getElementById('voiceButton');
                this.logsContainer = document.getElementById('logsContainer');
                this.statusContainer = document.getElementById('statusContainer');
                this.processStatus = document.getElementById('processStatus');
                this.serviceStatus = document.getElementById('serviceStatus');
                this.networkStatus = document.getElementById('networkStatus');
                this.resourceStatus = document.getElementById('resourceStatus');
            }



            initializeVoiceRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ continuous=true, –∞–ª–µ –∫–µ—Ä—É—î–º–æ –∞–≤—Ç–æ–ø–∞—É–∑–∞ / —Ä–µ—Å—Ç–∞—Ä—Ç –≤—Ä—É—á–Ω—É
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    this.recognition.lang = 'uk-UA';

                    this.recognition.onresult = (event) => {
                        let aggregatedFinal = '';
                        let aggregatedInterim = '';
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const res = event.results[i];
                            if (res.isFinal) {
                                aggregatedFinal += res[0].transcript;
                            } else {
                                aggregatedInterim += res[0].transcript;
                            }
                        }
                        // –û–Ω–æ–≤–ª—é—î–º–æ textarea (—Ñ—ñ–Ω–∞–ª—å–Ω–∏–π + –ø–æ—Ç–æ—á–Ω–∏–π —ñ–Ω—Ç–µ—Ä—ñ–º)
                        this.chatInput.value = (aggregatedFinal + aggregatedInterim).trim();

                        if (aggregatedFinal) {
                            this.lastFinalTimestamp = Date.now();
                            // SINGLE MODE: —Å—Ç–≤–æ—Ä—é—î–º–æ / –ø–µ—Ä–µ–Ω–æ—Å–∏–º–æ —Ç–∞–π–º–µ—Ä 3s –ø—ñ—Å–ª—è –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ —Ñ—ñ–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
                            if (this.voiceMode === 'single') {
                                if (this.singleModeSendTimer) {
                                    clearTimeout(this.singleModeSendTimer);
                                }
                                if ((aggregatedFinal.trim().length) >= this.MIN_FINAL_CHARS_TO_SEND) {
                                    this.singleModeSendTimer = setTimeout(() => {
                                        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —â–æ –º–∏–Ω—É–ª–æ 3s –±–µ–∑ –Ω–æ–≤–∏—Ö —Ñ—ñ–Ω–∞–ª—å–Ω–∏—Ö
                                        if (Date.now() - this.lastFinalTimestamp >= this.SINGLE_INACTIVITY_MS - 50) {
                                            this.stopListening();
                                            this.sendMessage();
                                        }
                                    }, this.SINGLE_INACTIVITY_MS);
                                }
                            }
                        }
                    };

                    this.recognition.onerror = (event) => {
                        this.logMessage(`[VOICE] Error: ${event.error}`, 'error');
                        this.stopListening();
                    };

                    this.recognition.onend = () => {
                        // –Ø–∫—â–æ continuous —Ç–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∏–π TTS ‚Äì –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—î–º–æ
                        if (this.voiceMode === 'continuous' && this.isListening && !this.TTS_ACTIVE) {
                            try { this.recognition.start(); } catch(e) {}
                        } else {
                            if (!this.TTS_ACTIVE) {
                                this.isListening = false;
                                this.updateVoiceButton();
                            }
                        }
                    };
                }
            }

            bindEvents() {
                // Chat input events
                this.chatInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                this.chatInput.addEventListener('input', () => {
                    this.autoResizeTextarea();
                });

                // Voice button events
                this.voiceButton.addEventListener('click', () => {
                    this.handleVoiceButtonClick();
                });

                // Session control events
                const newSessionBtn = document.getElementById('newSessionBtn');
                const continueSessionBtn = document.getElementById('continueSessionBtn');
                
                newSessionBtn.addEventListener('click', () => {
                    this.setSessionMode('new');
                });
                
                continueSessionBtn.addEventListener('click', () => {
                    this.setSessionMode('continue');
                });
            }



            setSessionMode(mode) {
                this.sessionMode = mode;
                
                // –û–Ω–æ–≤–ª—é—î–º–æ UI
                const newBtn = document.getElementById('newSessionBtn');
                const continueBtn = document.getElementById('continueSessionBtn');
                const currentSession = document.getElementById('currentSession');
                
                // –°–∫–∏–¥–∞—î–º–æ –≤—Å—ñ –∞–∫—Ç–∏–≤–Ω—ñ —Å—Ç–∞–Ω–∏
                newBtn.classList.remove('active');
                continueBtn.classList.remove('active');
                
                // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –∞–∫—Ç–∏–≤–Ω–∏–π —Å—Ç–∞–Ω
                if (mode === 'new') {
                    newBtn.classList.add('active');
                    currentSession.textContent = '–ù–æ–≤–∞ —Å–µ—Å—ñ—è';
                } else if (mode === 'continue') {
                    continueBtn.classList.add('active');
                    currentSession.textContent = '–ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏';
                } else {
                    currentSession.textContent = '–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ';
                }
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ —Å–∫–∏–¥–∞—î–º–æ —Ä–µ–∂–∏–º —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
                setTimeout(() => {
                    if (this.sessionMode === mode) {
                        this.setSessionMode('auto');
                    }
                }, 10000);
            }

            handleVoiceButtonClick() {
                this.clickCount++;
                
                if (this.clickTimer) {
                    clearTimeout(this.clickTimer);
                }

                this.clickTimer = setTimeout(() => {
                    if (this.clickCount === 1) {
                        // Single click - continuous mode
                        this.toggleContinuousMode();
                    } else if (this.clickCount === 2) {
                        // Double click - single mode
                        this.startSingleMode();
                    }
                    this.clickCount = 0;
                }, 300);
            }

            toggleContinuousMode() {
                if (this.voiceMode === 'continuous') {
                    this.stopListening();
                    this.voiceMode = 'off';
                } else {
                    this.startContinuousMode();
                }
            }

            startContinuousMode() {
                if (!this.recognition) return;
                
                this.voiceMode = 'continuous';
                this.startListening();
                this.logMessage('[VOICE] Continuous mode activated', 'info');
            }

            startSingleMode() {
                if (!this.recognition) return;
                
                this.voiceMode = 'single';
                this.startListening();
                this.logMessage('[VOICE] Single command mode', 'info');
            }

            startListening() {
                if (!this.recognition || this.isListening) return;
                
                this.isListening = true;
                this.recognition.start();
                this.updateVoiceButton();
            }

            stopListening() {
                if (!this.recognition || !this.isListening) return;
                
                this.isListening = false;
                this.recognition.stop();
                if (this.voiceMode === 'single') {
                    this.voiceMode = 'off';
                }
                this.updateVoiceButton();
            }

            updateVoiceButton() {
                this.voiceButton.className = 'voice-button';
                
                if (this.voiceMode === 'continuous') {
                    this.voiceButton.classList.add('continuous');
                    this.voiceButton.textContent = 'üîÑüé§';
                } else if (this.isListening) {
                    this.voiceButton.classList.add('listening');
                    this.voiceButton.textContent = 'üî¥üé§';
                } else {
                    this.voiceButton.textContent = 'üé§';
                }
            }

            autoResizeTextarea() {
                this.chatInput.style.height = 'auto';
                this.chatInput.style.height = Math.min(this.chatInput.scrollHeight, 60) + 'px';
            }

            async sendMessage() {
                const message = this.chatInput.value.trim();
                // –ë–ª–æ–∫—É–≤–∞—Ç–∏ –Ω–∞–¥—Ç–æ –∫–æ—Ä–æ—Ç–∫—ñ –∞–±–æ –ø–æ—Ä–æ–∂–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                if (!message || message.length < 2) {
                    this.logMessage('[CHAT] –í–≤–µ–¥—ñ—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (–º—ñ–Ω—ñ–º—É–º 2 —Å–∏–º–≤–æ–ª–∏)', 'warning');
                    return;
                }

                // –û—á–∏—Å—Ç–∏—Ç–∏ —Ç–∞–π–º–µ—Ä –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º—É, —è–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –≤—ñ–¥–ø—Ä–∞–≤–∏–≤ –≤—Ä—É—á–Ω—É
                if (this.singleModeSendTimer) {
                    clearTimeout(this.singleModeSendTimer);
                    this.singleModeSendTimer = null;
                }

                this.addMessage(message, 'user');
                this.chatInput.value = '';
                this.autoResizeTextarea();

                // –°–ø–æ—á–∞—Ç–∫—É –Ω–∞–º–∞–≥–∞—î–º–æ—Å—å —Å—Ç—Ä—ñ–º—ñ–Ω–≥–æ–º
                try {
                    await this.sendToAtlasStream(message);
                } catch (error) {
                    this.logMessage(`[CHAT] Stream error, fallback to non-stream: ${error.message}`, 'warning');
                    try {
                        const response = await this.sendToAtlas(message);
                        this.addMessage(response, 'assistant');
                    } catch (e2) {
                        this.addMessage(`–ü–æ–º–∏–ª–∫–∞: ${e2.message}`, 'assistant');
                        this.logMessage(`[CHAT] Error: ${e2.message}`, 'error');
                    }
                }
            }

            async sendToAtlas(message) {
                const baseUrl = (window.ATLAS_API_BASE || 'http://localhost:8080').replace(/\/$/, '');
                const url = `${baseUrl}/api/chat`;
                
                // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø —Å–µ—Å—ñ—ó –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏
                let sessionType = null;
                if (this.sessionMode === 'new') {
                    sessionType = 'new_session';
                } else if (this.sessionMode === 'continue') {
                    sessionType = 'continue_session';
                }
                
                const requestData = { 
                    message,
                    session_type: sessionType
                };
                
                try {
                    // –°—Ç–≤–æ—Ä—é—î–º–æ AbortController –¥–ª—è —Ç–∞–π–º–∞—É—Ç—É
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestData),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId); // –°–∫–∞—Å–æ–≤—É—î–º–æ —Ç–∞–π–º–∞—É—Ç —è–∫—â–æ –∑–∞–ø–∏—Ç —É—Å–ø—ñ—à–Ω–∏–π
                    
                    if (response.ok) {
                        const data = await response.json();
                        
                        // –û–Ω–æ–≤–ª—é—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –ø–æ—Ç–æ—á–Ω—É —Å–µ—Å—ñ—é
                        if (data.session_name) {
                            this.currentSessionName = data.session_name;
                            if (this.sessionMode === 'auto') {
                                document.getElementById('currentSession').textContent = data.session_name;
                            }
                        }
                        
                        // –°–∫–∏–¥–∞—î–º–æ —Ä–µ–∂–∏–º –ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ–≥–æ –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è
                        if (this.sessionMode !== 'auto') {
                            this.setSessionMode('auto');
                        }
                        
                        return data.response || data.message || '–í—ñ–¥–ø–æ–≤—ñ–¥—å –æ—Ç—Ä–∏–º–∞–Ω–∞';
                    } else {
                        this.logMessage(`[CHAT] HTTP ${response.status} (${url})`, 'warning');
                        return '–ü–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞';
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        this.logMessage(`[CHAT] –¢–∞–π–º–∞—É—Ç –∑–∞–ø–∏—Ç—É (${url})`, 'warning');
                        return '–¢–∞–π–º–∞—É—Ç –∑–∞–ø–∏—Ç—É (30 —Å–µ–∫)';
                    }
                    this.logMessage(`[CHAT] Network error: ${error.message}`, 'error');
                    return '–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è';
                }
            }

            // –ù–æ–≤–∏–π –º–µ—Ç–æ–¥: –ø–æ—Ç–æ–∫–æ–≤–∏–π —Å—Ç—Ä—ñ–º –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤—ñ–¥ –±–µ–∫–µ–Ω–¥—É
            async sendToAtlasStream(message) {
                const baseUrl = (window.ATLAS_API_BASE || 'http://localhost:8080').replace(/\/$/, '');
                const url = `${baseUrl}/api/chat/stream`;

                // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø —Å–µ—Å—ñ—ó –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏
                let sessionType = null;
                if (this.sessionMode === 'new') sessionType = 'new_session';
                else if (this.sessionMode === 'continue') sessionType = 'continue_session';

                const requestData = { message, session_type: sessionType };

                // –°—Ç–≤–æ—Ä—é—î–º–æ placeholder –¥–ª—è –∞—Å–∏—Å—Ç–µ–Ω—Ç–∞, —è–∫–∏–π –±—É–¥–µ–º–æ –æ–Ω–æ–≤–ª—é–≤–∞—Ç–∏ —Ç–æ–∫–µ–Ω–∞–º–∏
                const container = this.chatMessages;
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message assistant';
                const textDiv = document.createElement('div');
                textDiv.className = 'message-text';
                textDiv.textContent = '';
                const timeDiv = document.createElement('div');
                timeDiv.className = 'message-time';
                timeDiv.textContent = new Date().toLocaleTimeString();
                msgDiv.appendChild(textDiv);
                msgDiv.appendChild(timeDiv);
                container.appendChild(msgDiv);
                container.scrollTop = container.scrollHeight;

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5 * 60 * 1000); // 5 —Ö–≤ –º–∞–∫—Å–∏–º—É–º

                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData),
                    signal: controller.signal
                });

                if (!res.ok || !res.body) {
                    clearTimeout(timeoutId);
                    throw new Error(`HTTP ${res.status}`);
                }

                // –ß–∏—Ç–∞—î–º–æ text/event-stream –ø–æ—Å—Ç—Ä–æ—á–Ω–æ
                const reader = res.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let buffer = '';
                let doneReceived = false;

                const applyToken = (token) => {
                    if (!token) return;
                    textDiv.textContent += token;
                    container.scrollTop = container.scrollHeight;
                };

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });

                    // –ü–æ–¥—ñ—ó —Ä–æ–∑–¥—ñ–ª—è—é—Ç—å—Å—è –ø–æ—Ä–æ–∂–Ω—ñ–º —Ä—è–¥–∫–æ–º. –û–±—Ä–æ–±–ª—è—î–º–æ –ª—ñ–Ω—ñ—ó –ø–æ –æ–¥–Ω—ñ–π
                    const lines = buffer.split('\n');
                    buffer = lines.pop();
                    for (const raw of lines) {
                        const line = raw.trim();
                        if (!line || line.startsWith(':')) continue; // –∫–æ–º–µ–Ω—Ç–∞—Ä keepalive –∞–±–æ –ø–æ—Ä–æ–∂–Ω—å–æ
                        if (line.startsWith('data:')) {
                            const jsonStr = line.slice(5).trim();
                            try {
                                const obj = JSON.parse(jsonStr);
                                if (obj.type === 'token') {
                                    applyToken(obj.token || '');
                                } else if (obj.type === 'done') {
                                    doneReceived = true;
                                } else if (obj.type === 'status') {
                                    this.logMessage(`[SSE] ${obj.message || 'status'}`);
                                } else if (obj.type === 'error') {
                                    throw new Error(obj.error || 'stream error');
                                }
                            } catch (e) {
                                // –Ø–∫—â–æ –ø—Ä–∏–π—à–æ–≤ plain text —Ç–æ–∫–µ–Ω
                                applyToken(jsonStr);
                            }
                        }
                    }
                }

                clearTimeout(timeoutId);
                if (!doneReceived) {
                    // –Ø–∫—â–æ –±–µ–∫–µ–Ω–¥ –Ω–µ –ø—Ä–∏—Å–ª–∞–≤ –ø–æ–¥—ñ—é done ‚Äî –ø—Ä–æ—Å—Ç–æ –∑–∞–≤–µ—Ä—à—É—î–º–æ
                    this.logMessage('[SSE] –ü–æ—Ç—ñ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–æ');
                }

                // –°–∫–∏–¥–∞—î–º–æ —Ä–µ–∂–∏–º —Å–µ—Å—ñ—ó –ø—ñ—Å–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏
                if (this.sessionMode !== 'auto') this.setSessionMode('auto');
            }

            addMessage(text, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                
                const textDiv = document.createElement('div');
                textDiv.className = 'message-text';
                textDiv.textContent = text;
                
                const timeDiv = document.createElement('div');
                timeDiv.className = 'message-time';
                timeDiv.textContent = new Date().toLocaleTimeString();
                
                messageDiv.appendChild(textDiv);
                messageDiv.appendChild(timeDiv);
                
                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;

                // –Ø–∫—â–æ –ø—Ä–∏–π—à–ª–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –∞—Å–∏—Å—Ç–µ–Ω—Ç–∞ —ñ –º–∏ —É continuous —Ä–µ–∂–∏–º—ñ ‚Äì –ø–∞—É–∑–∞ —â–æ–± –Ω–µ —Å–ª—É—Ö–∞—Ç–∏ TTS (–µ–≤—Ä–∏—Å—Ç–∏–∫–∞)
                if (type === 'assistant' && this.voiceMode === 'continuous') {
                    this.simulateTTSPause(text);
                }
            }

            logMessage(text, type = 'info', customColor = null) {
                const logDiv = document.createElement('div');
                logDiv.className = 'log-line';
                
                // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –∫–∞—Å—Ç–æ–º–Ω–∏–π –∫–æ–ª—ñ—Ä –∞–±–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π
                if (customColor) {
                    logDiv.style.color = customColor;
                } else if (type === 'error') {
                    logDiv.classList.add('error');
                } else if (type === 'warning') {
                    logDiv.classList.add('warning');
                }
                
                logDiv.textContent = text;
                
                this.logsContainer.appendChild(logDiv);
                this.logsContainer.scrollTop = this.logsContainer.scrollHeight;
                
                // –ó–±–µ—Ä—ñ–≥–∞—Ç–∏ —Ç—ñ–ª—å–∫–∏ –æ—Å—Ç–∞–Ω–Ω—ñ 300 —Ä—è–¥–∫—ñ–≤ –ª–æ–≥—ñ–≤
                while (this.logsContainer.children.length > 300) {
                    this.logsContainer.removeChild(this.logsContainer.firstChild);
                }
            }

            startMCPLogging() {
                // –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —á–µ—Ä–µ–∑ Server-Sent Events –¥–æ /logs/stream –Ω–∞ frontend —Å–µ—Ä–≤–µ—Ä—ñ
                const baseUrl = (window.ATLAS_API_BASE || 'http://localhost:8080').replace(/\/$/, '');
                const streamUrl = `${baseUrl}/logs/stream`;
                this.logMessage(`[INIT] –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –ø–æ—Ç–æ–∫—É –ª–æ–≥—ñ–≤: ${streamUrl}`);
                let retryDelay = 2000;
                const maxDelay = 15000;

                const connect = () => {
                    try {
                        const es = new EventSource(streamUrl);
                        this._eventSource = es;
                        es.onopen = () => {
                            this.logMessage(`[SSE] –ü—ñ–¥–∫–ª—é—á–µ–Ω–æ (retryDelay=${retryDelay}ms)`);
                            retryDelay = 2000; // reset
                        };
                        es.onmessage = (evt) => {
                            if (!evt.data) return;
                            try {
                                const entry = JSON.parse(evt.data);
                                const ts = entry.timestamp || new Date().toISOString();
                                const lvl = (entry.level || 'INFO').toUpperCase();
                                const src = entry.source || 'atlas';
                                const msg = entry.message || '';
                                this.logMessage(`[${ts}] [${lvl}] ${src}: ${msg}`);
                            } catch (e) {
                                // raw line fallback
                                this.logMessage(`[SSE_RAW] ${evt.data}`);
                            }
                        };
                        es.onerror = () => {
                            es.close();
                            this.logMessage(`[SSE] –†–æ–∑'—î–¥–Ω–∞–Ω–æ, –ø–æ–≤—Ç–æ—Ä–Ω–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —á–µ—Ä–µ–∑ ${(retryDelay/1000).toFixed(1)}s`, 'warning');
                            setTimeout(connect, retryDelay);
                            retryDelay = Math.min(maxDelay, retryDelay * 1.7);
                        };
                    } catch (err) {
                        this.logMessage(`[SSE] –ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó: ${err.message}`, 'error');
                        setTimeout(connect, retryDelay);
                        retryDelay = Math.min(maxDelay, retryDelay * 1.7);
                    }
                };
                connect();
                // Fallback –ø–æ—á–∞—Ç–∫–æ–≤–µ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –ª–æ–≥—ñ–≤ —è–∫—â–æ SSE –ø–æ–≤—ñ–ª—å–Ω–æ —Å—Ç–∞—Ä—Ç—É—î
                this.pollLiveLogs(true);
            }

            async pollLiveLogs(initial = false) {
                // –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ª–æ–≥—ñ–≤ Goose
                if (!initial) return;
                const baseUrl = (window.ATLAS_API_BASE || 'http://localhost:8080').replace(/\/$/, '');
                const url = `${baseUrl}/logs?limit=100`;
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.logs && data.logs.length > 0) {
                            this.logsContainer.innerHTML = '';
                            data.logs.forEach(log => {
                                // –§–æ—Ä–º–∞—Ç—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ –∫–æ–ª—å–æ—Ä–∞–º–∏ —Ç–∞ —ñ–∫–æ–Ω–∫–∞–º–∏
                                let level = log.level.toLowerCase();
                                let icon = 'üìÑ';
                                let color = '#4a9c5a';
                                
                                if (log.source === 'goose_session') {
                                    icon = 'ü§ñ';
                                    color = '#00ff41';
                                } else if (log.source === 'goose_task') {
                                    icon = 'üìã';
                                    color = '#61dafb';
                                } else if (log.source === 'atlas_monitor') {
                                    icon = 'üîç';
                                    color = '#98fb98';
                                } else if (level === 'error') {
                                    icon = '‚ùå';
                                    color = '#d16969';
                                } else if (level === 'warning') {
                                    icon = '‚ö†Ô∏è';
                                    color = '#d19a66';
                                }
                                
                                const message = `[${log.timestamp}] ${icon} ${log.message}`;
                                this.logMessage(message, level, color);
                            });
                        }
                    }
                } catch(e) { 
                    this.logMessage(`[${new Date().toLocaleTimeString()}] ‚ùå Error fetching logs: ${e.message}`, 'error');
                }
                
                // –ó–∞–ø—É—Å–∫–∞—î–º–æ –ø–µ—Ä—ñ–æ–¥–∏—á–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–∂–Ω—ñ 2 —Å–µ–∫—É–Ω–¥–∏
                if (initial) {
                    setInterval(() => this.refreshLogs(), 2000);
                }
            }
            
            async refreshLogs() {
                // –ú–µ—Ç–æ–¥ –¥–ª—è –ø–µ—Ä—ñ–æ–¥–∏—á–Ω–æ–≥–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ª–æ–≥—ñ–≤
                const baseUrl = (window.ATLAS_API_BASE || 'http://localhost:8080').replace(/\/$/, '');
                const url = `${baseUrl}/logs?limit=50`;
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.logs && data.logs.length > 0) {
                            // –î–æ–¥–∞—î–º–æ —Ç—ñ–ª—å–∫–∏ –Ω–æ–≤—ñ –ª–æ–≥–∏ (–æ—Å—Ç–∞–Ω–Ω—ñ 5)
                            const recentLogs = data.logs.slice(-5);
                            recentLogs.forEach(log => {
                                let level = log.level.toLowerCase();
                                let icon = 'üìÑ';
                                let color = '#4a9c5a';
                                
                                if (log.source === 'goose_session') {
                                    icon = 'ü§ñ';
                                    color = '#00ff41';
                                } else if (log.source === 'goose_task') {
                                    icon = 'üìã';
                                    color = '#61dafb';
                                } else if (log.source === 'atlas_monitor') {
                                    icon = 'üîç';
                                    color = '#98fb98';
                                } else if (level === 'error') {
                                    icon = '‚ùå';
                                    color = '#d16969';
                                } else if (level === 'warning') {
                                    icon = '‚ö†Ô∏è';
                                    color = '#d19a66';
                                }
                                
                                const message = `[${log.timestamp}] ${icon} ${log.message}`;
                                this.logMessage(message, level, color);
                            });
                        }
                    }
                } catch(e) { 
                    // –Ü–≥–Ω–æ—Ä—É—î–º–æ –ø–æ–º–∏–ª–∫–∏ –ø—Ä–∏ –ø–µ—Ä—ñ–æ–¥–∏—á–Ω–æ–º—É –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ
                }
            }

            simulateTTSPause(text) {
                // –ï–≤—Ä–∏—Å—Ç–∏—á–Ω–∏–π —á–∞—Å –º–æ–≤–ª–µ–Ω–Ω—è: ~120 —Å–ª—ñ–≤/—Ö–≤ ‚âà 2 —Å–ª–æ–≤–∞/—Å–µ–∫; —Å–ª–æ–≤–æ ~5 —Å–∏–º–≤–æ–ª—ñ–≤
                const charCount = text.length;
                const approxSeconds = Math.min(10, Math.max(2, charCount / 11));
                this.TTS_ACTIVE = true;
                // –ü–∞—É–∑–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è
                if (this.isListening) {
                    try { this.recognition.stop(); } catch(e) {}
                }
                // –ü–ª–∞–Ω—É—î–º–æ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è
                if (this.TTSBlockTimer) clearTimeout(this.TTSBlockTimer);
                this.TTSBlockTimer = setTimeout(() => {
                    this.TTS_ACTIVE = false;
                    if (this.voiceMode === 'continuous') {
                        this.isListening = true;
                        try { this.recognition.start(); } catch(e) {}
                        this.updateVoiceButton();
                    }
                }, approxSeconds * 1000);
            }

            startStatusMonitoring() {
                // –ó–∞–ø—É—Å–∫ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É —Å—Ç–∞—Ç—É—Å—É —Å–∏—Å—Ç–µ–º–∏
                this.updateSystemStatus();
                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–∂–Ω—ñ 5 —Å–µ–∫—É–Ω–¥
                setInterval(() => {
                    this.updateSystemStatus();
                }, 5000);
            }

            async updateSystemStatus() {
                try {
                    // –û—Ç—Ä–∏–º—É—î–º–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º–∏
                    const response = await fetch('/api/status');
                    let status = {};
                    
                    if (response.ok) {
                        status = await response.json();
                    } else {
                        status = {
                            error: "Status unavailable",
                            timestamp: new Date().toISOString()
                        };
                    }
                    
                    // –î–æ–¥–∞—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ Goose —Å–µ—Å—ñ—ó
                    try {
                        const gooseResponse = await fetch('/api/goose/sessions');
                        if (gooseResponse.ok) {
                            const gooseData = await gooseResponse.json();
                            status.goose_sessions = {
                                count: gooseData.count || 0,
                                latest: gooseData.sessions && gooseData.sessions.length > 0 ? 
                                    gooseData.sessions[0].name : 'None',
                                status: gooseData.count > 0 ? 'active' : 'inactive'
                            };
                        }
                    } catch (e) {
                        status.goose_sessions = {
                            count: 0,
                            latest: 'Error',
                            status: 'error'
                        };
                    }
                    
                    this.renderSystemStatus(status);
                } catch (error) {
                    this.renderSystemStatus({
                        error: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
            }

            renderSystemStatus(status) {
                try {
                    // –ü—Ä–æ—Ü–µ—Å–∏
                    if (status.processes) {
                        const processHTML = Object.entries(status.processes).map(([type, info]) => {
                            const count = info.count || 0;
                            const statusClass = count > 0 ? 'online' : 'warning';
                            return `<div class="status-item ${statusClass}">${type}: ${count}</div>`;
                        }).join('');
                        this.processStatus.innerHTML = processHTML;
                    }

                    // –°–µ—Ä–≤—ñ—Å–∏
                    if (status.services) {
                        const serviceHTML = Object.entries(status.services).map(([name, info]) => {
                            const serviceStatus = info.status || 'unknown';
                            let statusClass = 'warning';
                            if (serviceStatus === 'online' || serviceStatus === 'operational' || serviceStatus === 'running') {
                                statusClass = 'online';
                            } else if (serviceStatus === 'offline' || serviceStatus === 'error') {
                                statusClass = 'error';
                            }
                            return `<div class="status-item ${statusClass}">${name}: ${serviceStatus}</div>`;
                        }).join('');
                        this.serviceStatus.innerHTML = serviceHTML;
                    }

                    // –ú–µ—Ä–µ–∂–∞
                    if (status.network && status.network.connections) {
                        const connCount = status.network.connections.count || 0;
                        const statusClass = connCount > 0 ? 'online' : 'warning';
                        this.networkStatus.innerHTML = `<div class="status-item ${statusClass}">Connections: ${connCount}</div>`;
                    }

                    // –†–µ—Å—É—Ä—Å–∏ –∑ –¥–æ–¥–∞–≤–∞–Ω–Ω—è–º Goose —Å–µ—Å—ñ–π
                    if (status.resources || status.goose_sessions) {
                        let resourceHTML = '';
                        
                        // CPU —Ç–∞ Disk (—è–∫ —Ä–∞–Ω—ñ—à–µ)
                        if (status.resources) {
                            if (status.resources.cpu && status.resources.cpu.usage_line) {
                                const cpuInfo = status.resources.cpu.usage_line;
                                resourceHTML += `<div class="status-item online">CPU: ${cpuInfo.substring(0, 30)}...</div>`;
                            } else {
                                resourceHTML += `<div class="status-item warning">CPU: --</div>`;
                            }
                            
                            if (status.resources.disk && status.resources.disk.usage_percent) {
                                const diskUsage = status.resources.disk.usage_percent;
                                const usageNum = parseInt(diskUsage);
                                const statusClass = usageNum > 90 ? 'error' : usageNum > 70 ? 'warning' : 'online';
                                resourceHTML += `<div class="status-item ${statusClass}">Disk: ${diskUsage}</div>`;
                            } else {
                                resourceHTML += `<div class="status-item warning">Disk: --</div>`;
                            }
                        }
                        
                        // –î–æ–¥–∞—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ Goose —Å–µ—Å—ñ—ó
                        if (status.goose_sessions) {
                            const count = status.goose_sessions.count || 0;
                            const latest = status.goose_sessions.latest || 'None';
                            const sessionStatus = status.goose_sessions.status || 'unknown';
                            
                            let statusClass = 'warning';
                            if (sessionStatus === 'active' && count > 0) {
                                statusClass = 'online';
                            } else if (sessionStatus === 'error') {
                                statusClass = 'error';
                            }
                            
                            resourceHTML += `<div class="status-item ${statusClass}">ü§ñ Goose: ${count} sessions</div>`;
                            if (latest !== 'None' && latest !== 'Error') {
                                const shortName = latest.length > 25 ? latest.substring(0, 25) + '...' : latest;
                                resourceHTML += `<div class="status-item online">üìã Latest: ${shortName}</div>`;
                            }
                        }
                        
                        this.resourceStatus.innerHTML = resourceHTML;
                    }

                } catch (error) {
                    console.error('Status rendering error:', error);
                }
            }
        }

        // Initialize the interface when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –µ–∫–∑–µ–º–ø–ª—è—Ä –≥–ª–æ–±–∞–ª—å–Ω–æ, —â–æ–± —ñ–Ω—à—ñ —Å–∫—Ä–∏–ø—Ç–∏ –º–æ–≥–ª–∏ –∑–≤–µ—Ä—Ç–∞—Ç–∏—Å—è
            window.atlasInterface = new AtlasMinimalInterface();
        });
    </script>

    <!-- –£–±—Ä–∞–ª–∏ –¥—É–±–ª—é—é—â–∏–π –Ω–µ—Å—Ç—Ä–∏–º–∏–Ω–≥–æ–≤—ã–π —Å–∫—Ä–∏–ø—Ç; –≤—Å—è –ª–æ–≥–∏–∫–∞ —á–∞—Ç—É –≤ AtlasMinimalInterface -->
</body>
</html>
