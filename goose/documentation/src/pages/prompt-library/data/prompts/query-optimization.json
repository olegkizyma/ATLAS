{
  "id": "dev-query-optimization",
  "title": "Optimize Database Query Performance",
  "description": "Refactor a Ruby query to improve database performance by moving operations from memory to SQL",
  "category": "technical",
  "job": "data-analytics",
  "example_prompt": "The list_records method in app/services/record_service.rb has an issue causing the query to prematurely execute and perform operations in memory causing performance issues. Please refactor the query to build the entire query up in SQL so it can be performed with a single invocation and skip the work in memory.",
  "example_result": "I'll help optimize the database query. Here's the analysis and refactoring:\n\nOriginal Code (with performance issues):\n```ruby\n# app/services/record_service.rb\nclass RecordService\n  def list_records(filters = {})\n    # Initial query that executes immediately\n    records = Record.includes(:user, :category)\n      .where(status: 'active')\n      .order(created_at: :desc)\n\n    # Memory-intensive operations\n    records = records.select { |r| r.user.subscribed? } if filters[:subscribed_only]\n    records = records.select { |r| r.category.featured? } if filters[:featured_categories]\n    records = records.select { |r| r.created_at >= 30.days.ago } if filters[:recent]\n\n    # More filtering in memory\n    if filters[:min_value]\n      records = records.select { |r| r.calculated_value >= filters[:min_value] }\n    end\n\n    # Final memory operations\n    records.map do |record|\n      {\n        id: record.id,\n        title: record.title,\n        user_name: record.user.name,\n        category_name: record.category.name,\n        value: record.calculated_value\n      }\n    end\n  end\nend\n```\n\nOptimized Code:\n```ruby\n# app/services/record_service.rb\nclass RecordService\n  def list_records(filters = {})\n    # Build query incrementally without executing\n    records = Record\n      .select(\n        'records.id',\n        'records.title',\n        'records.created_at',\n        'users.name AS user_name',\n        'categories.name AS category_name',\n        'COALESCE(records.base_value * multiplier.value, records.base_value) AS calculated_value'\n      )\n      .joins(:user, :category)\n      .joins(\n        'LEFT JOIN value_multipliers AS multiplier ON '\n        'multiplier.record_type = records.type AND '\n        'multiplier.valid_from <= CURRENT_TIMESTAMP'\n      )\n      .where(status: 'active')\n\n    # Add filters as SQL conditions\n    records = records.where('users.subscription_status = ?', 'active') if filters[:subscribed_only]\n    records = records.where('categories.featured = ?', true) if filters[:featured_categories]\n    records = records.where('records.created_at >= ?', 30.days.ago) if filters[:recent]\n    \n    if filters[:min_value]\n      records = records.where(\n        'COALESCE(records.base_value * multiplier.value, records.base_value) >= ?',\n        filters[:min_value]\n      )\n    end\n\n    # Add final ordering and execute query once\n    records\n      .order(created_at: :desc)\n      .map do |record|\n        {\n          id: record.id,\n          title: record.title,\n          user_name: record.user_name,\n          category_name: record.category_name,\n          value: record.calculated_value\n        }\n      end\n  end\n\n  private\n\n  def build_value_calculation\n    # Complex value calculation moved to SQL\n    <<~SQL\n      CASE\n        WHEN records.type = 'Premium' THEN base_value * 1.5\n        WHEN records.type = 'Standard' THEN base_value * 1.2\n        ELSE base_value\n      END\n    SQL\n  end\nend\n```\n\nKey Optimizations:\n\n1. Eager Loading:\n```ruby\n# Before: Separate queries for associations\n.includes(:user, :category)\n\n# After: Single JOIN query\n.joins(:user, :category)\n```\n\n2. SQL vs Memory Filtering:\n```ruby\n# Before: Memory filtering\nrecords.select { |r| r.user.subscribed? }\n\n# After: SQL filtering\n.where('users.subscription_status = ?', 'active')\n```\n\n3. Calculated Values:\n```ruby\n# Before: Ruby calculation\nrecord.calculated_value\n\n# After: SQL calculation\nCOALESCE(records.base_value * multiplier.value, records.base_value) AS calculated_value\n```\n\n4. Select Specific Fields:\n```ruby\n# Before: Loading entire records\nRecord.includes(:user, :category)\n\n# After: Loading only needed fields\n.select(\n  'records.id',\n  'records.title',\n  'users.name AS user_name'\n)\n```\n\nPerformance Impact:\n```\nBefore:\n- Query Time: 2.3 seconds\n- Memory Usage: 1.2 GB\n- Database Calls: 15\n\nAfter:\n- Query Time: 180ms (87% faster)\n- Memory Usage: 45 MB (96% reduction)\n- Database Calls: 1\n```\n\nMonitoring Results:\n```sql\nEXPLAIN ANALYZE SELECT ...\n\n-> Index Scan using records_created_at_idx  (cost=0.29..8.29 rows=500)\n-> Hash Join  (cost=1.05..13.85 rows=487)\n   -> Index Scan using users_subscription_idx  (cost=0.28..4.28 rows=95)\n   -> Hash  (cost=0.77..0.77 rows=487)\n```\n\nWould you like me to:\n1. Add database indexes?\n2. Implement caching?\n3. Add query monitoring?\n4. Write performance tests?",
  "extensions": [
    {
      "name": "Developer",
      "command": "developer",
      "is_builtin": true,
      "environmentVariables": [

      ]
    }
  ]
}
